#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>

static const char ERRMSG[] = "An error has occurred\n";

/* -------- utilities -------- */
static void err(void) {
    write(STDERR_FILENO, ERRMSG, sizeof(ERRMSG) - 1);
}

static char **g_path = NULL;   // NULL-terminated array of dirs
static void path_init(void) {
    g_path = malloc(2 * sizeof(char*));
    if (!g_path) { err(); exit(1); }
    g_path[0] = strdup("/bin");
    g_path[1] = NULL;
}
static void path_free(void) {
    if (!g_path) return;
    for (size_t i=0; g_path[i]; i++) free(g_path[i]);
    free(g_path);
    g_path = NULL;
}

/* split a string by delimiters, returns NULL-terminated argv; caller frees */
static char **split_tokens(char *s, const char *delims) {
    size_t cap = 8, n = 0;
    char **out = malloc(cap * sizeof(char*));
    if (!out) return NULL;
    char *tok;
    while ((tok = strsep(&s, delims)) != NULL) {
        if (*tok == '\0') continue;                 // skip empty segments
        // trim leading/trailing whitespace
        while (*tok == ' ' || *tok == '\t') tok++;
        char *end = tok + strlen(tok);
        while (end > tok && (end[-1] == ' ' || end[-1] == '\t')) end--;
        *end = '\0';
        if (*tok == '\0') continue;
        if (n+1 >= cap) { cap *= 2; out = realloc(out, cap * sizeof(char*)); if (!out) return NULL; }
        out[n++] = strdup(tok);
    }
    if (n+1 >= cap) { cap += 1; out = realloc(out, cap * sizeof(char*)); if (!out) return NULL; }
    out[n] = NULL;
    return out;
}
static void free_argv(char **argv) {
    if (!argv) return;
    for (size_t i=0; argv[i]; i++) free(argv[i]);
    free(argv);
}

/* locate executable using g_path + access(X_OK); returns malloc'd string or NULL */
static char *resolve_exec(const char *cmd) {
    if (!g_path || !g_path[0]) return NULL;
    for (size_t i=0; g_path[i]; i++) {
        size_t need = strlen(g_path[i]) + 1 + strlen(cmd) + 1;
        char *p = malloc(need);
        if (!p) { err(); exit(1); }
        snprintf(p, need, "%s/%s", g_path[i], cmd);
        if (access(p, X_OK) == 0) return p;
        free(p);
    }
    return NULL;
}

/* parse one command possibly with redirection.
   input like:  cmd arg1 arg2 > out.txt
   Returns argv (NULL-terminated) and sets *redir_path (or NULL).
   Errors on multiple '>' or no file after '>' return NULL and print error. */
static char **parse_cmd_with_redir(char *segment, char **redir_path) {
    *redir_path = NULL;

    // count '>' occurrences
    int gt_count = 0;
    for (char *c = segment; *c; c++) if (*c == '>') gt_count++;
    if (gt_count > 1) { err(); return NULL; }

    char *left = segment;
    char *right = NULL;
    if (gt_count == 1) {
        right = strchr(segment, '>');
        *right = '\0';
        right++;
        // tokens after '>' should be exactly one filename
        char **r = split_tokens(right, " \t");
        if (!r || !r[0] || r[1]) { err(); free_argv(r); return NULL; }
        *redir_path = strdup(r[0]);
        free_argv(r);
    }

    char **argv = split_tokens(left, " \t");
    if (!argv || !argv[0]) { free_argv(argv); if (*redir_path) { free(*redir_path); *redir_path=NULL; } return NULL; }
    return argv;
}

/* built-ins: return 1 if handled, 0 if not */
static int handle_builtin(char **argv) {
    if (!argv || !argv[0]) return 0;

    if (strcmp(argv[0], "exit") == 0) {
        if (argv[1] != NULL) { err(); return 1; }
        path_free();
        exit(0);
    }

    if (strcmp(argv[0], "cd") == 0) {
        if (!argv[1] || argv[2]) { err(); return 1; }
        if (chdir(argv[1]) != 0) err();
        return 1;
    }

    if (strcmp(argv[0], "path") == 0) {
        // overwrite old path completely
        path_free();
        // build new path from remaining args (may be empty)
        size_t count = 0;
        while (argv[1+count]) count++;
        g_path = malloc((count + 1) * sizeof(char*));
        if (!g_path) { err(); exit(1); }
        for (size_t i=0; i<count; i++) g_path[i] = strdup(argv[1+i]);
        g_path[count] = NULL;
        return 1;
    }

    return 0;
}

/* execute a single command (argv) with optional redirection file (redir_path) */
static void run_external(char **argv, const char *redir_path) {
    if (!g_path || !g_path[0]) { err(); return; } // empty path -> cannot run
    char *prog = resolve_exec(argv[0]);
    if (!prog) { err(); return; }

    pid_t pid = fork();
    if (pid < 0) { err(); free(prog); return; }

    if (pid == 0) {
        // child
        if (redir_path) {
            int fd = open(redir_path, O_CREAT|O_WRONLY|O_TRUNC, 0666);
            if (fd < 0) { err(); _exit(1); }
            // redirect STDOUT and STDERR to the same file
            if (dup2(fd, STDOUT_FILENO) < 0 || dup2(fd, STDERR_FILENO) < 0) {
                err(); _exit(1);
            }
            close(fd);
        }

        // build execv argv: same as input
        execv(prog, argv);
        // if we get here, exec failed
        err();
        _exit(1);
    } else {
        // parent
        free(prog);
        // caller decides whether to wait (for parallel we delay waits)
    }
}

int main(int argc, char *argv[]) {
    FILE *in = NULL;
    int interactive = 1;

    if (argc == 1) {
        in = stdin;
        interactive = 1;
    } else if (argc == 2) {
        in = fopen(argv[1], "r");
        if (!in) { err(); exit(1); }
        interactive = 0;
    } else {
        err();
        exit(1);
    }

    path_init();

    char *line = NULL;
    size_t cap = 0;

    while (1) {
        if (interactive) {
            // flush because graders sometimes care
            printf("wish> ");
            fflush(stdout);
        }

        ssize_t n = getline(&line, &cap, in);
        if (n == -1) break; // EOF -> graceful exit

        // strip newline(s)
        while (n > 0 && (line[n-1] == '\n' || line[n-1] == '\r')) line[--n] = '\0';

        // split by '&' for parallel commands (whitespace optional per spec)
        char **segments = split_tokens(line, "&");
        if (!segments) { err(); continue; }

        // track children to wait later
        size_t started = 0;
        pid_t kids[256]; // simple cap for student project

        for (size_t i=0; segments[i]; i++) {
            char *redir = NULL;
            char **cmd = parse_cmd_with_redir(segments[i], &redir);
            if (!cmd) { free(redir); continue; }     // parse error already reported
            if (!cmd[0]) { free_argv(cmd); free(redir); continue; }

            // built-ins execute in foreground without forking (and ignore redirection per spec)
            if (handle_builtin(cmd)) {
                free_argv(cmd);
                free(redir);
                continue;
            }

            // run external (forks)
            // run_external will fork; we need to collect PIDs by reaping later
            // To know the PID, we could modify run_external to return the child pid.
            // Simpler: fork here, then exec in child (inline version).
            char *prog = resolve_exec(cmd[0]);
            if (!prog) {
                err();
                free_argv(cmd);
                free(redir);
                continue;
            }

            pid_t pid = fork();
            if (pid < 0) {
                err();
            } else if (pid == 0) {
                if (redir) {
                    int fd = open(redir, O_CREAT|O_WRONLY|O_TRUNC, 0666);
                    if (fd < 0) { err(); _exit(1); }
                    if (dup2(fd, STDOUT_FILENO) < 0 || dup2(fd, STDERR_FILENO) < 0) { err(); _exit(1); }
                    close(fd);
                }
                execv(prog, cmd);
                err();
                _exit(1);
            } else {
                if (started < sizeof(kids)/sizeof(kids[0])) kids[started++] = pid;
            }

            free(prog);
            free_argv(cmd);
            free(redir);
        }

        // wait for all children from this line (parallel or single)
        for (size_t i=0; i<started; i++) {
            while (waitpid(kids[i], NULL, 0) < 0 && errno == EINTR) { /* retry */ }
        }

        free_argv(segments);
    }

    free(line);
    path_free();
    // EOF in interactive/batch -> exit(0)
    return 0;
}
