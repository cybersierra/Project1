#define _GNU_SOURCE   // unlocks GNU extensions for getline() and strsep()
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>   // for fork(), execv(), access(), chdir()
#include <sys/wait.h> // for waitpid()
#include <fcntl.h>    // for open(), O_CREAT, O_WRONLY, O_TRUNC
#include <errno.h>    // for errno values

// The *only* allowed error message per spec
static const char ERRMSG[] = "An error has occurred\n";

/* ===========================================================
   ==========   BASIC ERROR HANDLER + GLOBAL PATH   ===========
   =========================================================== */

// Prints the official error message to STDERR
static void err(void) {
    write(STDERR_FILENO, ERRMSG, sizeof(ERRMSG) - 1);
}

// Global variable storing the search PATH as a NULL-terminated array
// Example: ["/bin", "/usr/bin", NULL]
static char **g_path = NULL;

// Addy
// Initialize default path to contain just "/bin"
static void path_init(void) {
    // Clean up old path
    if (g_path){
        path_free();
    }

    // Allocating slots
    g_path = calloc(2, sizeof *g_path);
    if (!g_path) {
        err();
        exit(1);
    }

    // Storing copy of /bin
    g_path[0] = strdup("/bin");
    if (!g_path[0]) {
        free(g_path);
        g_path = NULL;
        err();
        exit(1);
    }

}

// Addy
// Frees all memory associated with the path array
static void path_free(void) {
    if (!g_path){
        return;
    }

    // Free directory string
    for (size_t i = 0; g_path[i]; i++){
        free(g_path[i]);
    }

    // Free the pointer
    free(g_path);
    g_path = NULL;
}

/* ===========================================================
   ==========        STRING PARSING HELPERS          =========
   =========================================================== */

/*
 * split_tokens():
 * Splits a string `s` into tokens separated by any of the given `delims`
 * (like " " or "&" or "\t"). Uses strsep() so it handles multiple
 * consecutive delimiters gracefully.
 * Returns a NULL-terminated array of strdupâ€™d strings.
 * Caller must free with free_argv().
 */
static char **split_tokens(char *s, const char *delims) {
    size_t cap = 8, n = 0;
    char **out = malloc(cap * sizeof(char*));
    if (!out) return NULL;
    char *tok;

    while ((tok = strsep(&s, delims)) != NULL) {
        // skip empty pieces
        if (*tok == '\0') continue;

        // trim whitespace on both ends
        while (*tok == ' ' || *tok == '\t') tok++;
        char *end = tok + strlen(tok);
        while (end > tok && (end[-1] == ' ' || end[-1] == '\t')) end--;
        *end = '\0';

        if (*tok == '\0') continue;

        // expand storage if needed
        if (n + 1 >= cap) {
            cap *= 2;
            out = realloc(out, cap * sizeof(char*));
            if (!out) return NULL;
        }

        out[n++] = strdup(tok);
    }

    // terminate array with NULL
    if (n + 1 >= cap) {
        cap += 1;
        out = realloc(out, cap * sizeof(char*));
        if (!out) return NULL;
    }
    out[n] = NULL;
    return out;
}

// Addy
/* Frees token arrays created by split_tokens() */
static void free_argv(char **argv) {
    if (!argv){
    return;
    }

    for (size_t i=0; argv[i]; i++) {
        free(argv[i]);
    }
    free(argv);
}

/* ===========================================================
   ==========        PATH SEARCH FOR EXECUTABLES     =========
   =========================================================== */

/*
 * resolve_exec():
 * Given a command name (like "ls"), check each directory in g_path.
 * Build a full path like "/bin/ls" and test if it exists & is executable
 * via access(path, X_OK).
 * Returns malloc'd string with the full path, or NULL if not found.
 */
static char *resolve_exec(const char *cmd) {
    if (!g_path || !g_path[0]) return NULL;
    for (size_t i=0; g_path[i]; i++) {
        size_t need = strlen(g_path[i]) + 1 + strlen(cmd) + 1;
        char *p = malloc(need);
        if (!p) { err(); exit(1); }
        snprintf(p, need, "%s/%s", g_path[i], cmd);
        if (access(p, X_OK) == 0) return p;  // found a valid executable
        free(p);
    }
    return NULL;
}

/* ===========================================================
   ==========   PARSE COMMAND + HANDLE REDIRECTION   ==========
   =========================================================== */

/*
 * parse_cmd_with_redir():
 * Takes a command line segment (like "ls -l > out.txt").
 * Splits out the filename following '>' (if any) and returns
 * an argv[] for the command itself.
 *
 * - Only ONE '>' allowed.
 * - Exactly ONE filename allowed after '>'.
 * - Returns NULL if syntax is invalid.
 */


// Addy
// Trims leading and trailing whitespace from a string
static char *trim_whitespace(char *string){
    char* original_pointer = string;
    char* backend_pointer;

    // Skip leading whitespace
    while (*original_pointer == ' ' || *original_pointer == '\t'){
        original_pointer++;
    }

    // Remove trailing whitespace
    backend_pointer = original_pointer + strlen(original_pointer);

    while (backend_pointer > original_pointer && (backend_pointer[-1] == ' ' || backend_pointer[-1] == '\t' || backend_pointer[-1] == '\n')){
        backend_pointer--;
    }

    *backend_pointer = '\0';
    return original_pointer;
}

static char **parse_cmd_with_redir(char *segment, char **redir_path) {
    *redir_path = NULL;

    if (!segment) {
        err();
        return NULL;
    }

    // Counts > (Requires there only to be 0 or 1 '>')
    int redir_count = 0;
    for (char *count = segment; *count; c++) {
        if (*count == '>'){
            redir_count++;
        }
    }

    // If more than one '>', then NULL
    if (redir_count > 1) {
        err();
        return NULL;
    }

    char *cmd = segment;
    char *filename = NULL;

    if (redir_count == 1) {
        filename = strchr(segment, '>');
        *filename = '\0';
        filename++;

        // Trim both sides
        cmd = trim_whitespace(cmd);
        filename = trim_whitespace(filename);

        char **tokens = split_tokens(filename, " \t");
        if (!tokens || !tokens[0] || tokens[1]) {
            free_argv(tokens);
            err();
            return NULL;
        }

        *redir_path = strdup(tokens[0]);
        free_argv(tokens);
    } else {
        cmd = trim_whitespace(cmd);
    }

    char **argv = split_tokens(cmd, " \t");
    if (!argv || !argv[0]) {
        free_argv(argv);
        if (*redir_path) {
            free(*redir_path);
            *redir_path = NULL; 
        }
        err();
        return NULL;
    }

    return argv;
}

/* ===========================================================
   ==========        BUILT-IN COMMAND HANDLER         =========
   =========================================================== */

/*
 * handle_builtin():
 * Checks if argv[0] is one of the built-in commands (exit, cd, path).
 * Executes them directly inside the shell (no forking).
 * Returns 1 if handled, 0 otherwise.
 */
static int handle_builtin(char **argv) {
    if (!argv || !argv[0]) return 0;

    // ======= exit =======
    if (strcmp(argv[0], "exit") == 0) {
        if (argv[1] != NULL) { err(); return 1; } // exit takes no args
        path_free();
        exit(0);
    }

    // ======= cd =======
    if (strcmp(argv[0], "cd") == 0) {
        if (!argv[1] || argv[2]) { err(); return 1; } // exactly one arg
        if (chdir(argv[1]) != 0) err();
        return 1;
    }

    // ======= path =======
    if (strcmp(argv[0], "path") == 0) {
        // clear old path
        path_free();

        // count new dirs
        size_t count = 0;
        while (argv[1+count]) count++;

        // rebuild global path
        g_path = malloc((count + 1) * sizeof(char*));
        if (!g_path) { err(); exit(1); }
        for (size_t i=0; i<count; i++)
            g_path[i] = strdup(argv[1+i]);
        g_path[count] = NULL;
        return 1;
    }

    return 0; // not a built-in command
}

/* ===========================================================
   ==========      EXECUTE EXTERNAL COMMANDS          =========
   =========================================================== */

/*
 * run_external():
 * Launches an external program (like /bin/ls).
 * Handles redirection (if redir_path != NULL).
 * Uses fork() + execv() + wait().
 * Parent continues after child creation.
 */
static void run_external(char **argv, const char *redir_path) {
    if (!g_path || !g_path[0]) { err(); return; } // empty path means nothing executable
    char *prog = resolve_exec(argv[0]);
    if (!prog) { err(); return; }

    pid_t pid = fork();
    if (pid < 0) { err(); free(prog); return; }

    if (pid == 0) {
        // ===== child process =====
        if (redir_path) {
            // open file for writing, truncate if exists
            int fd = open(redir_path, O_CREAT|O_WRONLY|O_TRUNC, 0666);
            if (fd < 0) { err(); _exit(1); }

            // redirect stdout and stderr to file
            if (dup2(fd, STDOUT_FILENO) < 0 || dup2(fd, STDERR_FILENO) < 0) {
                err();
                _exit(1);
            }
            close(fd);
        }

        execv(prog, argv); // replaces process image
        // only runs if execv() fails
        err();
        _exit(1);
    } else {
        // ===== parent process =====
        free(prog);
        // we don't wait here; caller may do it later for parallel commands
    }
}

/* ===========================================================
   ==========                MAIN LOOP                =========
   =========================================================== */

int main(int argc, char *argv[]) {
    FILE *in = NULL;
    int interactive = 1; // 1 = prompt mode, 0 = batch mode

    // ======= Determine input source =======
    if (argc == 1) {
        in = stdin;
        interactive = 1;
    } else if (argc == 2) {
        in = fopen(argv[1], "r");
        if (!in) { err(); exit(1); }
        interactive = 0;
    } else {
        err();
        exit(1);
    }

    path_init(); // set default /bin path
    char *line = NULL;
    size_t cap = 0;

    // ======= MAIN SHELL LOOP =======
    while (1) {
        // show prompt only in interactive mode
        if (interactive) {
            printf("wish> ");
            fflush(stdout);
        }

        ssize_t n = getline(&line, &cap, in);
        if (n == -1) break; // EOF -> exit gracefully

        // strip trailing newlines
        while (n > 0 && (line[n-1] == '\n' || line[n-1] == '\r')) line[--n] = '\0';

        // split by '&' â†’ multiple parallel commands per line
        char **segments = split_tokens(line, "&");
        if (!segments) { err(); continue; }

        // collect child PIDs to wait for them all later
        size_t started = 0;
        pid_t kids[256]; // arbitrary limit (enough for tests)

        // process each command segment
        for (size_t i=0; segments[i]; i++) {
            char *redir = NULL;
            char **cmd = parse_cmd_with_redir(segments[i], &redir);
            if (!cmd) { free(redir); continue; } // syntax error already handled
            if (!cmd[0]) { free_argv(cmd); free(redir); continue; }

            // check for built-ins (execute immediately)
            if (handle_builtin(cmd)) {
                free_argv(cmd);
                free(redir);
                continue;
            }

            // non-built-in: run external command
            char *prog = resolve_exec(cmd[0]);
            if (!prog) {
                err();
                free_argv(cmd);
                free(redir);
                continue;
            }

            pid_t pid = fork();
            if (pid < 0) {
                err();
            } else if (pid == 0) {
                // in child: handle redirection and execv
                if (redir) {
                    int fd = open(redir, O_CREAT|O_WRONLY|O_TRUNC, 0666);
                    if (fd < 0) { err(); _exit(1); }
                    if (dup2(fd, STDOUT_FILENO) < 0 || dup2(fd, STDERR_FILENO) < 0) { err(); _exit(1); }
                    close(fd);
                }
                execv(prog, cmd);
                err();
                _exit(1);
            } else {
                // parent tracks this child PID
                if (started < sizeof(kids)/sizeof(kids[0])) kids[started++] = pid;
            }

            free(prog);
            free_argv(cmd);
            free(redir);
        }

        // ======= Wait for all child processes =======
        for (size_t i=0; i<started; i++) {
            while (waitpid(kids[i], NULL, 0) < 0 && errno == EINTR) {
                // retry if interrupted by a signal
            }
        }

        free_argv(segments);
    }

    // cleanup on EOF
    free(line);
    path_free();
    return 0;
}
